# Burp AI Fuzzer 插件设计文档

## 1. 项目概述
### 1.1 背景
在渗透测试过程中，针对特定接口的参数 Fuzz 是一项核心任务。传统的 Fuzz 依赖于通用的字典，往往缺乏针对性，导致效率低下。本项目旨在开发一个 Burp Suite 插件，利用大语言模型（LLM）的理解能力，根据接口的路径、参数名及上下文，动态生成高质量的 Fuzz 字典，并支持自定义位置的自动化测试。

### 1.2 目标
- 集成 AI 能力，根据 API 上下文生成语义化的 Fuzz 载荷。
- 支持在 Burp Suite 中手动选择请求中的任意位置作为 Fuzz 点。
- 提供灵活的字典管理和 AI 配置界面。
- 兼容最新的 Burp Montoya API。

## 2. 核心功能设计
### 2.1 AI 参数字典生成
- **上下文提取**：提取 HTTP 请求的 URL、方法、Header、以及现有参数结构（JSON/Form/XML）。
- **提示词工程 (Prompt Engineering)**：构建专用的 Prompt，让 AI 识别接口功能（如登录、搜索、转账等），并针对性地输出可能的异常输入、边界值或注入 Payload。
- **流式返回与处理**：支持从 AI 接口获取字典并实时展示。

### 2.2 自定义 Fuzz 位置 (Intruder 增强)
- **标记机制**：允许用户在 HTTP 编辑器中选中字符串并将其标记为 `§payload§`。
- **多位置支持**：支持单个请求中设置多个 Fuzz 点，并提供不同的替换策略（如：Sniper, Battering ram, Pitchfork, Cluster bomb）。

### 2.3 响应分析与过滤
- **对比机制**：通过基准测试（Baseline）对比 Fuzz 后的响应，识别状态码、响应长度、响应时间的变化。
- **AI 辅助分析**：可选功能，将异常响应返回给 AI 进行二次判断，识别潜在漏洞。

## 3. 系统架构
### 3.1 技术栈
- **开发语言**：Java 17 / Kotlin
- **API 框架**：Burp Montoya API (最新版)
- **UI 库**：Java Swing (兼容 Burp 原生风格)
- **网络通信**：OkHttp 4.x (用于调用 AI 接口)

### 3.2 模块划分
- **`ui` 模块**：负责配置面板（API Key、模型选择）、Fuzz 任务监控界面。
- **`ai` 模块**：负责与 OpenAI/Claude/本地模型（如 Ollama）通信，处理数据格式化。
- **`fuzzer` 模块**：核心执行逻辑，管理并发请求、Payload 替换和结果收集。
- **`context` 模块**：解析请求结构，为 AI 提供语义信息。

## 4. 关键流程
### 4.1 字典生成流程
1. 用户在 Proxy 或 Repeater 中右键选择 "Send to AI Fuzzer"。
2. 插件解析请求，生成上下文描述。
3. 调用 AI 接口，请求生成针对该接口的 20-50 个恶意/异常参数值。
4. 插件将结果填充到临时字典池，用户可手动微调。

### 4.2 Fuzz 执行流程
1. 用户标记 Fuzz 位置。
2. 配置并发线程数和延迟。
3. 启动任务，插件自动替换 Payload 并发送请求。
4. 结果实时展示在任务列表中，支持导出 CSV。

## 5. UI/UX 设计要点
- **右键菜单集成**：无缝嵌入 Burp 的常用操作。
- **配置面板**：
  - AI 供应商配置（API Base URL, API Key, Model Name）。
  - Prompt 模板自定义。
- **结果表格**：支持排序、搜索和一键重发请求。

## 6. 安全与隐私
- **数据脱敏**：在将请求发送给外部 AI 之前，自动过滤或提示用户确认敏感信息（如 Cookie, Authorization Header）。
- **本地化支持**：支持配置指向本地部署的 LLM（如通过 Ollama），确保私有环境下的数据安全。

## 7. 实施计划
1. **第一阶段**：搭建 Montoya API 基础框架，实现简单的右键菜单和配置界面。
2. **第二阶段**：集成 AI 接口调用逻辑，实现字典自动生成。
3. **第三阶段**：实现自定义位置标记与 Fuzz 引擎核心逻辑。
4. **第四阶段**：优化 UI 交互与结果过滤机制。
